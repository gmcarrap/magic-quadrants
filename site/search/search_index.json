{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Magic Quadrants","text":"<p>To calculate the magic squares first, all prime numbers in the interval between 0 and N are calculated, where N is the input value.</p> <p>Then, the arithmetic sequences of length L=9 are calculated since we will work with matrices of DIMENSION = 9.</p> <p>Finally, the matrices are formed following Green's and Tao's Theorem from the calculated arithmetic sequences. In addition, we will calculate if these matrices are magic squares and they will appear in the implemented API.</p> <p>To test the execution follow the commands below:</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>python api_server.py</code> - Raises the API server.</li> <li><code>N</code> - Enter a value for N. For values of N greater than 2000 there are already magic squares.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>    mkdocs.yml    # The configuration file.\n    docs/\n        api-implementation.md\n        arithmetic_sequence.md\n        index.md  \n        magic-quadrants.md\n        main.md\n        prime-numbers.md\n    src/\n        services/\n            arithmetic_sequence.py\n            magic_quadrants.py\n            prime_numbers.py\n        tests/\n    api_server.py\n    main.py\nReadme.md\nrequirements.txt\n</code></pre>"},{"location":"api-implementation/","title":"Service Implementation","text":"<p>Flask Application for Magic Quadrants</p> <p>This application provides endpoints and forms to calculate and display magic quadrants based on a given parameter N.</p> <p>Endpoints: - <code>/magic-quadrants-json</code>: Accepts JSON input to calculate magic quadrants. - <code>/magic-quadrants</code>: Renders an HTML form to input N and displays magic quadrants.</p> <p>Functions: - <code>get_magic_quadrants</code>: Endpoint to calculate magic quadrants from JSON input. - <code>magic_quadrants_form</code>: Endpoint to render HTML form for inputting N and displaying magic quadrants.</p>"},{"location":"api-implementation/#api_server.get_magic_quadrants","title":"<code>get_magic_quadrants()</code>","text":"<p>Endpoint to calculate magic quadrants from JSON input.</p> <p>Accepts JSON with a parameter N, calculates magic quadrants using 'main' function.</p> <p>Returns:</p> Name Type Description <code>JSON</code> <p>Magic quadrants calculated based on input N.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If N is not provided or is not a valid integer.</p> Source code in <code>api_server.py</code> <pre><code>@app.route('/magic-quadrants-json', methods=['POST'])\ndef get_magic_quadrants():\n    \"\"\"\n    Endpoint to calculate magic quadrants from JSON input.\n\n    Accepts JSON with a parameter N, calculates magic quadrants using 'main' function.\n\n    Returns:\n        JSON: Magic quadrants calculated based on input N.\n\n    Raises:\n        ValueError: If N is not provided or is not a valid integer.\n    \"\"\"\n\n    data = request.json\n    N = data.get('N')\n\n    if N is None:\n        return jsonify({\"error\": \"Parameter N not provided\"}), 400\n\n    try:\n        N = int(N)\n    except ValueError:\n        return jsonify({\"error\": \"The value of N must be an integer.\"}), 400\n\n    magic_quadrants = main(N)\n    return jsonify(magic_quadrants)\n</code></pre>"},{"location":"api-implementation/#api_server.magic_quadrants_form","title":"<code>magic_quadrants_form()</code>","text":"<p>Endpoint to render HTML form for inputting N and displaying magic quadrants.</p> <p>Renders 'form.html' template for GET requests. Processes POST requests, validates N, calculates magic quadrants using 'main' function, and renders 'index.html'.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Rendered HTML page with magic quadrants or error message.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If N is not provided or is not a valid integer.</p> Source code in <code>api_server.py</code> <pre><code>@app.route('/magic-quadrants', methods=['GET', 'POST'])\ndef magic_quadrants_form():\n    \"\"\"\n    Endpoint to render HTML form for inputting N and displaying magic quadrants.\n\n    Renders 'form.html' template for GET requests. Processes POST requests,\n    validates N, calculates magic quadrants using 'main' function, and renders 'index.html'.\n\n    Returns:\n        str: Rendered HTML page with magic quadrants or error message.\n\n    Raises:\n        ValueError: If N is not provided or is not a valid integer.\n    \"\"\"\n    if request.method == 'POST':\n        N = request.form.get('N')\n\n        if not N:\n            return \"Please enter a value for N.\"\n\n        try:\n            N = int(N)\n        except ValueError:\n            return \"N must be an integer.\"\n\n        magic_quadrants = main(N)\n        return render_template('index.html', magic_quadrants=magic_quadrants, N=N)\n\n    return render_template('form.html')\n</code></pre>"},{"location":"arithmetic_sequence/","title":"Arithmetic Sequence Implementation","text":""},{"location":"arithmetic_sequence/#src.services.arithmetic_sequence.ArithmeticSequence","title":"<code>ArithmeticSequence</code>","text":"<p>Class to find arithmetic sequences within a list of integers.</p> <p>Attributes:</p> Name Type Description <code>list</code> <code>list</code> <p>List of integers where sequences will be searched.</p> <code>set_numbers</code> <code>set</code> <p>Set of unique numbers in the list.</p> <code>sequences</code> <code>list</code> <p>List to store found arithmetic sequences.</p> <p>Methods:</p> Name Description <code>find_sequence</code> <p>Finds and returns all arithmetic sequences of length n within the list.</p> Source code in <code>src/services/arithmetic_sequence.py</code> <pre><code>class ArithmeticSequence:\n    \"\"\"\n    Class to find arithmetic sequences within a list of integers.\n\n    Attributes:\n        list (list): List of integers where sequences will be searched.\n        set_numbers (set): Set of unique numbers in the list.\n        sequences (list): List to store found arithmetic sequences.\n\n    Methods:\n        find_sequence(n=9):\n            Finds and returns all arithmetic sequences of length n within the list.\n    \"\"\"\n\n    def __init__(self, list):\n        \"\"\"\n        Initializes an instance of ArithmeticSequence.\n\n        Args:\n            lista (list): List of integers where sequences will be searched.\n        \"\"\"\n        self.list = list\n        self.set_numbers = set(list)\n        self.sequences = []\n\n\n    def find_sequence(self, n=DIMENSION):\n        \"\"\"\n        Finds all arithmetic sequences of length n within the list.\n\n        Args:\n            n (int): Length of arithmetic sequences to search for (default: 9).\n\n        Returns:\n            list: List of found arithmetic sequences, each sequence is a list of integers.\n\n        Notes:\n            Uses a brute-force approach to search for arithmetic sequences in the list.\n            Updates the `sequences` attribute with the found sequences.\n\n        Example:\n            &gt;&gt;&gt; sequence = ArithmeticSequence([1, 2, 3, 5, 8, 13])\n            &gt;&gt;&gt; sequence.find_sequence(3)\n            [[1, 2, 3], [2, 3, 5], [1, 3, 5]]\n        \"\"\"\n\n        for first_number in range(len(self.list)):\n            print(first_number)\n            for second_number in range(first_number + 1, len(self.list)):\n\n                difference = self.list[second_number] - self.list[first_number]\n\n                possible_succession = [self.list[first_number], self.list[second_number]]\n\n                for comparison_following_numbers in range(2, n):\n\n                    next_number = self.list[second_number] + difference\n\n                    if next_number in self.set_numbers:\n\n                        possible_succession.append(next_number)\n\n                        second_number = self.list.index(next_number) \n\n                    else:\n                        break\n\n                if len(possible_succession) == n:\n\n                    self.sequences.append(possible_succession)\n\n        return self.sequences\n</code></pre>"},{"location":"arithmetic_sequence/#src.services.arithmetic_sequence.ArithmeticSequence.__init__","title":"<code>__init__(list)</code>","text":"<p>Initializes an instance of ArithmeticSequence.</p> <p>Parameters:</p> Name Type Description Default <code>lista</code> <code>list</code> <p>List of integers where sequences will be searched.</p> required Source code in <code>src/services/arithmetic_sequence.py</code> <pre><code>def __init__(self, list):\n    \"\"\"\n    Initializes an instance of ArithmeticSequence.\n\n    Args:\n        lista (list): List of integers where sequences will be searched.\n    \"\"\"\n    self.list = list\n    self.set_numbers = set(list)\n    self.sequences = []\n</code></pre>"},{"location":"arithmetic_sequence/#src.services.arithmetic_sequence.ArithmeticSequence.find_sequence","title":"<code>find_sequence(n=DIMENSION)</code>","text":"<p>Finds all arithmetic sequences of length n within the list.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Length of arithmetic sequences to search for (default: 9).</p> <code>DIMENSION</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of found arithmetic sequences, each sequence is a list of integers.</p> Notes <p>Uses a brute-force approach to search for arithmetic sequences in the list. Updates the <code>sequences</code> attribute with the found sequences.</p> Example <p>sequence = ArithmeticSequence([1, 2, 3, 5, 8, 13]) sequence.find_sequence(3) [[1, 2, 3], [2, 3, 5], [1, 3, 5]]</p> Source code in <code>src/services/arithmetic_sequence.py</code> <pre><code>def find_sequence(self, n=DIMENSION):\n    \"\"\"\n    Finds all arithmetic sequences of length n within the list.\n\n    Args:\n        n (int): Length of arithmetic sequences to search for (default: 9).\n\n    Returns:\n        list: List of found arithmetic sequences, each sequence is a list of integers.\n\n    Notes:\n        Uses a brute-force approach to search for arithmetic sequences in the list.\n        Updates the `sequences` attribute with the found sequences.\n\n    Example:\n        &gt;&gt;&gt; sequence = ArithmeticSequence([1, 2, 3, 5, 8, 13])\n        &gt;&gt;&gt; sequence.find_sequence(3)\n        [[1, 2, 3], [2, 3, 5], [1, 3, 5]]\n    \"\"\"\n\n    for first_number in range(len(self.list)):\n        print(first_number)\n        for second_number in range(first_number + 1, len(self.list)):\n\n            difference = self.list[second_number] - self.list[first_number]\n\n            possible_succession = [self.list[first_number], self.list[second_number]]\n\n            for comparison_following_numbers in range(2, n):\n\n                next_number = self.list[second_number] + difference\n\n                if next_number in self.set_numbers:\n\n                    possible_succession.append(next_number)\n\n                    second_number = self.list.index(next_number) \n\n                else:\n                    break\n\n            if len(possible_succession) == n:\n\n                self.sequences.append(possible_succession)\n\n    return self.sequences\n</code></pre>"},{"location":"magic-quadrants/","title":"Magic Quadrants Implementation","text":"<p>A magic square is a square matrix (equal number of rows and columns) where the sum of numbers in each row, each column, and both main diagonals always equals the same value, known as the magic constant.</p> <p>The most famous magic square is the Lo Shu Square, which is a 3x3 magic square (3 rows by 3 columns). It is named after an ancient Chinese river and is represented as follows:</p> <pre><code>                                4   9   2\n                                3   5   7\n                                8   1   6\n</code></pre> <p>In this magic square:</p> <ul> <li>Each row, column, and both main diagonals sum to 15.</li> <li>It is symmetric in that it can be rotated or reflected without changing its magic properties.</li> <li>Historically, it has been associated with Chinese cosmology and has significant symbolic and mathematical applications across different cultures.</li> </ul>"},{"location":"magic-quadrants/#src.services.magic_quadrants.MagicQuadrants","title":"<code>MagicQuadrants</code>","text":"<p>The class calculates the magic matrix following the Green Tao Theorem. The theorem calculates the magic  squares of arithmetic sequences based on the magic square of \u201cLo Shu\u201d.</p> <p>Attributes:</p> Name Type Description <code>arithmetic_sequence</code> <code>list</code> <p>List of prime numbers satisfying an arithmetic sequence of length N.</p> Source code in <code>src/services/magic_quadrants.py</code> <pre><code>class MagicQuadrants:\n    \"\"\"\n    The class calculates the magic matrix following the Green Tao Theorem. The theorem calculates the magic \n    squares of arithmetic sequences based on the magic square of \u201cLo Shu\u201d.\n\n    Attributes:\n        arithmetic_sequence (list): List of prime numbers satisfying an arithmetic sequence of length N.\n    \"\"\"\n\n    def __init__(self, elements):\n        \"\"\"\n        From an input list it checks if it has the necessary values to form the matrix of the set dimension.\n\n        Args:\n            elements (list): List of numbers that fulfill an arithmetic sequence.\n\n        Raises:\n            ValueError: Return If the list contains exactly the number of elements equal to the dimension of the matrix.\n        \"\"\"\n        if len(elements) != DIMENSION:\n            raise ValueError(\"The list must contain exactly the number of elements equal to the dimension of the matrix\")\n        self.elements = elements\n\n    def get_matrix(self):\n        \"\"\"\n        Assuming the positions of the numbers of the \u201cLo Shu\u201d base matrix, from an ascendingly ordered list \n        of numbers of dimension N, the positions where the numbers of the arithmetic sequence will form a square\n        matrix can be established without using computational time.\n\n        Returns:\n            matrix: Magic quadrant formed by prime numbers.\n        \"\"\"\n\n        matrix = [[0]*3 for _ in range(int(np.sqrt(DIMENSION)))]\n\n        matrix[0][0], matrix[0][1], matrix[0][2] = self.elements[3], self.elements[8], self.elements[1]\n        matrix[1][0], matrix[1][1], matrix[1][2] = self.elements[2], self.elements[4], self.elements[6]\n        matrix[2][0], matrix[2][1], matrix[2][2] = self.elements[7], self.elements[0], self.elements[5]\n\n        return matrix\n\n    def get_magic_quadrant(self):\n        \"\"\"\n        Check if the matrix formed from Green Tao's theorem of arithmetic sequences is a magic square.\n\n        Returns:\n            bool, list: returns whether the array is a magic square or not, plus the array if it is.\n        \"\"\"\n        matrix_formed = self.get_matrix()\n\n        reference_sum = sum(matrix_formed[0])\n\n        for row in matrix_formed:\n\n            if sum(row) != reference_sum:\n                return False\n\n        for column in range(int(np.sqrt(DIMENSION))):\n\n            colum_sum = 0\n\n            for row in range(int(np.sqrt(DIMENSION))):\n\n                colum_sum += matrix_formed[row][column]\n\n            if colum_sum != reference_sum:\n\n                return False\n\n        main_diagonal_sum = sum(matrix_formed[diagonal][diagonal] for diagonal in range(int(np.sqrt(DIMENSION))))\n\n        if main_diagonal_sum != reference_sum:\n\n            return False\n\n        secondary_diagonal_sum = sum(matrix_formed[diagonal][2-diagonal] for diagonal in range(int(np.sqrt(DIMENSION))))\n\n        if secondary_diagonal_sum != reference_sum:\n            return False\n\n        matrix = list(chain(*matrix_formed))\n        return True, matrix\n</code></pre>"},{"location":"magic-quadrants/#src.services.magic_quadrants.MagicQuadrants.__init__","title":"<code>__init__(elements)</code>","text":"<p>From an input list it checks if it has the necessary values to form the matrix of the set dimension.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>list</code> <p>List of numbers that fulfill an arithmetic sequence.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Return If the list contains exactly the number of elements equal to the dimension of the matrix.</p> Source code in <code>src/services/magic_quadrants.py</code> <pre><code>def __init__(self, elements):\n    \"\"\"\n    From an input list it checks if it has the necessary values to form the matrix of the set dimension.\n\n    Args:\n        elements (list): List of numbers that fulfill an arithmetic sequence.\n\n    Raises:\n        ValueError: Return If the list contains exactly the number of elements equal to the dimension of the matrix.\n    \"\"\"\n    if len(elements) != DIMENSION:\n        raise ValueError(\"The list must contain exactly the number of elements equal to the dimension of the matrix\")\n    self.elements = elements\n</code></pre>"},{"location":"magic-quadrants/#src.services.magic_quadrants.MagicQuadrants.get_magic_quadrant","title":"<code>get_magic_quadrant()</code>","text":"<p>Check if the matrix formed from Green Tao's theorem of arithmetic sequences is a magic square.</p> <p>Returns:</p> Type Description <p>bool, list: returns whether the array is a magic square or not, plus the array if it is.</p> Source code in <code>src/services/magic_quadrants.py</code> <pre><code>def get_magic_quadrant(self):\n    \"\"\"\n    Check if the matrix formed from Green Tao's theorem of arithmetic sequences is a magic square.\n\n    Returns:\n        bool, list: returns whether the array is a magic square or not, plus the array if it is.\n    \"\"\"\n    matrix_formed = self.get_matrix()\n\n    reference_sum = sum(matrix_formed[0])\n\n    for row in matrix_formed:\n\n        if sum(row) != reference_sum:\n            return False\n\n    for column in range(int(np.sqrt(DIMENSION))):\n\n        colum_sum = 0\n\n        for row in range(int(np.sqrt(DIMENSION))):\n\n            colum_sum += matrix_formed[row][column]\n\n        if colum_sum != reference_sum:\n\n            return False\n\n    main_diagonal_sum = sum(matrix_formed[diagonal][diagonal] for diagonal in range(int(np.sqrt(DIMENSION))))\n\n    if main_diagonal_sum != reference_sum:\n\n        return False\n\n    secondary_diagonal_sum = sum(matrix_formed[diagonal][2-diagonal] for diagonal in range(int(np.sqrt(DIMENSION))))\n\n    if secondary_diagonal_sum != reference_sum:\n        return False\n\n    matrix = list(chain(*matrix_formed))\n    return True, matrix\n</code></pre>"},{"location":"magic-quadrants/#src.services.magic_quadrants.MagicQuadrants.get_matrix","title":"<code>get_matrix()</code>","text":"<p>Assuming the positions of the numbers of the \u201cLo Shu\u201d base matrix, from an ascendingly ordered list  of numbers of dimension N, the positions where the numbers of the arithmetic sequence will form a square matrix can be established without using computational time.</p> <p>Returns:</p> Name Type Description <code>matrix</code> <p>Magic quadrant formed by prime numbers.</p> Source code in <code>src/services/magic_quadrants.py</code> <pre><code>def get_matrix(self):\n    \"\"\"\n    Assuming the positions of the numbers of the \u201cLo Shu\u201d base matrix, from an ascendingly ordered list \n    of numbers of dimension N, the positions where the numbers of the arithmetic sequence will form a square\n    matrix can be established without using computational time.\n\n    Returns:\n        matrix: Magic quadrant formed by prime numbers.\n    \"\"\"\n\n    matrix = [[0]*3 for _ in range(int(np.sqrt(DIMENSION)))]\n\n    matrix[0][0], matrix[0][1], matrix[0][2] = self.elements[3], self.elements[8], self.elements[1]\n    matrix[1][0], matrix[1][1], matrix[1][2] = self.elements[2], self.elements[4], self.elements[6]\n    matrix[2][0], matrix[2][1], matrix[2][2] = self.elements[7], self.elements[0], self.elements[5]\n\n    return matrix\n</code></pre>"},{"location":"main/","title":"Service Implementation","text":"<p>The following service has been implemented to calculate the magic squares formed by prime numbers. </p> <p>A magic square of size N is a matrix formed by N squares. So that the sum of each row, column and diagonals is equal. The most famous magic square was named \u201cLo Shu\u201d and has the form:</p> <pre><code>                                4   9   2\n                                3   5   7\n                                8   1   6\n</code></pre> <p>If we notice, the values of such a magic square contain an arithmetic succession, that is, the difference between the values is always equal.</p> <p>Because, in order to calculate magic squares formed by prime numbers, we are going to look for those sets of prime numbers of dimension N that fulfill an arithmetic sequence. This is known as the Green and Tao theorem.</p>"},{"location":"main/#main.main","title":"<code>main(N)</code>","text":"<p>Service that implements the calculation of magic squares formed by prime numbers.</p> <p>Attributes:</p> Name Type Description <code>N</code> <code>int</code> <p>The upper limit for calculating prime numbers.</p> Source code in <code>main.py</code> <pre><code>def main(N):\n    \"\"\"\n    Service that implements the calculation of magic squares formed by prime numbers.\n\n    Attributes:\n        N (int): The upper limit for calculating prime numbers.\n    \"\"\"\n    prime_calculator = PrimeNumberCalculator(N)\n    prime_numbers = prime_calculator.get_primes()\n    print(prime_numbers)\n    arithmetic_sequence = ArithmeticSequence(prime_numbers)\n    arithmetic_sequence_per_dimension = arithmetic_sequence.find_sequence(n=DIMENSION)\n    print(arithmetic_sequence_per_dimension)\n\n    magic_quadrants = []\n    for arithmetic_sequence_matrix in arithmetic_sequence_per_dimension:\n\n        get_matrix = MagicQuadrants(arithmetic_sequence_matrix)\n\n        is_magic_quadrant, matrix_results = get_matrix.get_magic_quadrant()\n\n        if is_magic_quadrant:\n\n            magic_quadrants.append({\n                \"name\": f\"Magic Quadrant {len(magic_quadrants) + 1}\",\n                \"elements\": matrix_results\n            })\n\n    return magic_quadrants\n</code></pre>"},{"location":"prime-numbers/","title":"Prime Numbers Calculation","text":"<p>The Sieve of Eratosthenes is an efficient algorithm for finding all prime numbers up to a given limit. It works by marking multiples of each prime number as it iterates through the list of natural numbers. The unmarked numbers at the end of the process are primes. It's a simple yet powerful algorithm that takes advantage of the fact that multiples of a prime number are always non-prime. This significantly reduces the number of operations needed to identify prime numbers compared to more naive methods. It's a valuable tool in mathematics and computer science for working with prime numbers. </p>"},{"location":"prime-numbers/#src.services.prime_numbers.PrimeNumberCalculator","title":"<code>PrimeNumberCalculator</code>","text":"<p>A class to calculate prime numbers up to a specified maximum number using the Sieve of Eratosthenes.</p> <p>Attributes:</p> Name Type Description <code>max_number</code> <code>int</code> <p>The upper limit for calculating prime numbers.</p> <code>primes_numbers</code> <code>list</code> <p>A list to store the calculated prime numbers.</p> Source code in <code>src/services/prime_numbers.py</code> <pre><code>class PrimeNumberCalculator:\n    \"\"\"\n    A class to calculate prime numbers up to a specified maximum number using the Sieve of Eratosthenes.\n\n    Attributes:\n        max_number (int): The upper limit for calculating prime numbers.\n        primes_numbers (list): A list to store the calculated prime numbers.\n    \"\"\"\n\n    def __init__(self, max_number):\n        \"\"\"\n        Initializes a PrimeNumberCalculator object with the given maximum number.\n\n        Args:\n            max_number (int): The maximum number up to which to calculate prime numbers.\n        \"\"\"\n\n        self.max_number = max_number\n        self.primes_numbers = []\n        self._calculate_primes()\n\n    def _calculate_primes(self):\n        \"\"\"\n        Calculates all prime numbers up to the maximum number using the Sieve of \n        Eratosthenes algorithm.\n\n        This method implements the Sieve of Eratosthenes algorithm to calculate all \n        prime numbers up to the maximum number specified in the instance of PrimeNumberCalculator.\n\n        Returns:\n            primes_numbers (list): A list of calculated prime numbers.\n        \"\"\"\n\n        list_all_numbers = [True] * (self.max_number + 1)\n        list_all_numbers[0] = list_all_numbers[1] = False\n\n        for number in range(FIRST_PRIME_NUMBER, self.max_number + 1):\n            if list_all_numbers[number]:\n                for index_number_prime in range(number * number, self.max_number + 1, number):\n                    list_all_numbers[index_number_prime] = False\n\n                self.primes_numbers.append(number)\n\n        prime_numbers = self.get_primes()\n\n        return prime_numbers\n\n    def get_primes(self):\n        \"\"\"\n        Returns the list of calculated prime numbers.\n\n        Returns:\n            primes_numbers (list): A list of calculated prime numbers.\n        \"\"\"\n        return self.primes_numbers\n</code></pre>"},{"location":"prime-numbers/#src.services.prime_numbers.PrimeNumberCalculator.__init__","title":"<code>__init__(max_number)</code>","text":"<p>Initializes a PrimeNumberCalculator object with the given maximum number.</p> <p>Parameters:</p> Name Type Description Default <code>max_number</code> <code>int</code> <p>The maximum number up to which to calculate prime numbers.</p> required Source code in <code>src/services/prime_numbers.py</code> <pre><code>def __init__(self, max_number):\n    \"\"\"\n    Initializes a PrimeNumberCalculator object with the given maximum number.\n\n    Args:\n        max_number (int): The maximum number up to which to calculate prime numbers.\n    \"\"\"\n\n    self.max_number = max_number\n    self.primes_numbers = []\n    self._calculate_primes()\n</code></pre>"},{"location":"prime-numbers/#src.services.prime_numbers.PrimeNumberCalculator.get_primes","title":"<code>get_primes()</code>","text":"<p>Returns the list of calculated prime numbers.</p> <p>Returns:</p> Name Type Description <code>primes_numbers</code> <code>list</code> <p>A list of calculated prime numbers.</p> Source code in <code>src/services/prime_numbers.py</code> <pre><code>def get_primes(self):\n    \"\"\"\n    Returns the list of calculated prime numbers.\n\n    Returns:\n        primes_numbers (list): A list of calculated prime numbers.\n    \"\"\"\n    return self.primes_numbers\n</code></pre>"}]}